/*
描述
    我是王大锤，已经过去半个月了，今天是2013年12月13日，又是一个黑色星期五。万万没想到，不，已经是预料之中的事情了，雇主王师傅由于怀疑我是叛徒，开除了我。我，又失去了工作。 
    13号、星期五，这是多么特殊的一个日子。（失去工作无事可干的）我很好奇13号在星期五比在其他日子少吗?为了回答这个问题,写一个程序，要求计算每个月的十三号落在周一到周日的次数。给定N，要求计算1900年1月1日至1900+N-1年12月31日中十三号分别落在星期六，星期日，星期一，…星期五的次数，N为正整数且不大于400. 

    请勿使用元素数目大于20的数组.
关于输入
    一个正整数N. 1<=N<=400.
关于输出
    七个在一行且相分开的整数,它们代表13日是星期六,星期日,星期一...星期五的次数.. 
	最后一个数字后无空格
例子输入
	20
例子输出
	36 33 34 33 35 35 34
提示
	1. 1900年1月1日是星期一，1900年1月13日是星期六 
	
	2. 注意题目输出要求从星期六开始 
	
	3. 已知一天的星期(x)，求另一天是星期几(y)的方法：y=(x+d)%7，d是这两天相差的天数
*/
#include<iostream>
using namespace std;
int main()
{
	int N, i, j, days = 0;
	int dOM[12] = { 3,0,3,2,3,2,3,3,2,3,2,3 };
	int cnt[7] = { 0 };
	cin >> N;
	for (i = 1; i <= N; i++)
	{
		dOM[1] = 0;
		if ((1900 + i - 1) % 4 == 0 && (1900 + i - 1) % 100 != 0 || (1900 + i - 1) % 400 == 0)
			dOM[1] = 1;
		for (j = 0; j < 12; j++)
		{
			if (i == N && j == 11)
				break;
			cnt[days] += 1;
			days += dOM[j];
			days %= 7;
		}
	}
	cnt[days] += 1;
	cout << cnt[0];
	for (i = 1; i < 7; i++)
		cout << " " << cnt[i];
	cout << endl;
	return 0;
}
